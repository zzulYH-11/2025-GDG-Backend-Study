# 목차

1. Spring의 핵심 설계 - 계층형 아키텍처 (Layered Architecture)
2. 웹 요청의 진입점 - 컨트롤러 계층 (Controller Layer)
3. 스프링 빈 & 의존성 주입 (Bean & DI)
4. 비즈니스 로직의 중심 - 서비스 계층 (Service Layer)



# 스프링 계층 아키텍처 (Layered Architecture)
![](https://velog.velcdn.com/images/jjulu0227/post/67549313-8461-4331-aafa-b7ac8600e5d8/image.png)
-> 스프링 계층 아키텍처

강의에서는 백엔드 애플리케이션의 구조를 레스토랑에 비유하여 설명했습니다. 

- 브라우저 (손님): 프론트엔드 또는 클라이언트 역할을 하며, API 요청을 보냅니다.

- 컨트롤러 (웨이터) Controller:

브라우저(클라이언트)와 직접 소통하며 특정 엔드포인트로 들어오는 HTTP 요청을 가장 먼저 처리하고, HTTP 응답을 반환합니다. 비즈니스 로직을 모르기 때문에 서비스 계층과 DTO를 사용하여 데이터를 주고받으며 작업을 지시합니다. 

- 서비스 (주방장) Service:

비즈니스 로직 (고기 굽는 법, 요리)을 모두 알고 처리하는 핵심 계층입니다. 컨트롤러와 레포지토리 사이에서 중계 역할을 합니다. 

- 레포지토리/DAO (창고 관리자) Repository / DAO:

데이터 접근 객체(Data Access Object)로, 데이터베이스(DB)와의 입출력 및 관리를 담당합니다. 

- DB (냉장/냉동 창고): 실제 데이터가 저장되는 공간입니다. 

# 데이터 전달 객체(DTO)와 핵심 객체(Entity)

각 계층 간 데이터를 전달하고 저장하기 위한 객체에 대한 설명입니다.

- DTO (Data Transfer Object)	
주문서, 영수증 (소통 목적)	
소통 목적에 맞는 필요한 정보만 전달 (예: 메뉴 이름, 수량). 
계층 간 데이터 전송을 담당합니다. 

- Entity (엔티티)
원재료 (모든 정보)
DB 테이블과 매핑되는 핵심 객체입니다. 유통기한, 원산지 등 모든 정보를 포함합니다. 데이터 일관성 및 보안을 위해 외부에 직접 노출시키지 않습니다. 

# 컨트롤러 (Controller) 계층 주요 개념

- 주요 어노테이션 및 개념:

@RestController: @Controller와 @ResponseBody의 기능을 합친 어노테이션으로, 메서드의 반환값을 HTTP 응답 본문(Body)에 직접 작성하게 해줍니다. 

@RequestMapping: 클래스 레벨에서 정의하여 컨트롤러의 모든 세부 엔드포인트에 적용되는 공통 엔드포인트를 설정할 수 있습니다. 

@PathVariable: URL 경로에 포함된 변수({memberId}와 같은)를 추출하여 사용하며, 특정 자원을 식별하는 식별자로 활용됩니다. 

@RequestBody: HTTP 요청의 본문(Body)에 담긴 JSON 데이터를 자바 객체(DTO)로 변환하는 역할을 담당합니다. 

ResponseEntity: 응답에 대한 HTTP 상태 코드(Status Code)와 응답 본문(Body)을 유연하게 설정하여 반환하는 타입입니다. 


# 서비스 (Service) 계층과 트랜잭션

- 트랜잭션 (Transaction):

여러 개의 작업을 하나의 단위로 묶어 처리하는 개념입니다.

트랜잭션 내의 작업들은 **원자성(Atomicity)**을 보장해야 합니다. 
즉, 모든 작업이 성공하거나, 하나라도 실패하면 모두 실패(롤백)해야 합니다. 

@Transactional 어노테이션을 사용하여 스프링에게 해당 메서드가 트랜잭션 단위로 처리되어야 함을 명시합니다. 

읽기 전용(readOnly = true): 데이터 수정이 없는 조회(GET) 메서드에 붙여, 읽기 전용 옵션을 설정하여 성능을 최적화하고 수정 가능성을 막습니다.![](https://velog.velcdn.com/images/jjulu0227/post/62de9244-780d-4903-a6e7-1f8617d2c785/image.png)
 

# 패키지 구조  

- 계층형

 애플리케이션을 기능별로 나눈다.( 컨트롤러는 컨트롤러, 서비스는 서비스 )

- 도메인형

 member, product 등 도메인(기능 단위) 별로 패키지를 나누고 그 안에 컨트롤러, 서비스, DTO 등 모든 관련 클래스를 모아두는 방식입니다. 새 도메인을 추가해도 다른 곳에 영향이 없다. 코드 탐색 및 유지보수에 용이합니다.

# 스프링 빈/의존성 주입
![](https://velog.velcdn.com/images/jjulu0227/post/88a40a2c-5b6c-4923-9442-0102ecc4fd34/image.png)
-> 스프링 애플리케이션 구조

- 스프링 빈 (Spring Bean):

애플리케이션 전역에서 사용되는 공용 객체를 말하며, **스프링 컨테이너(Application Context)**라는 저장소에 보관됩니다. 

필요한 빈은 스프링 프레임워크가 자동으로 가져다 준다. 빈을 요구하는 객체 역시 스프링 빈이다.

- 빈 등록 방법
	
    - 설정 파일 작성 (수동 등록)
    
    - 컴포넌트 스캔 (자동 등록)
		@RestController, @Service, @Repository 등의 어노테이션이 붙은 클래		스는 	컴포넌트 스캔을 통해 자동으로 스프링 빈으로 등록됩니다.

- 의존성 주입 (Dependency Injection, DI):

객체가 직접 의존하는 객체(다른 빈)를 생성하지 않고, 스프링 컨테이너로부터 받아와 사용하는 방식입니다. 

장점: 객체를 매번 생성하지 않고 재사용하여 메모리 사용을 효율화할 수 있습니다. 

- 의존성 주입 방법
	- 생성자 주입
		가장 권장되는 DI 방식입니다. final로 선언한 뒤 생성자에 @Autowired를 사용
        (만약 생성자가 하나만 있다면, @Autowired 생략 가능)
        
        -간단 버전
          	필요한 의존성을 final 키워드를 사용해 추가.
			@RequiredArgsConstructor를 사용해 생성자를 추가한다.
	- 필드 주입
    - 수정자 주입 (세터 주입)
---
링크
http://www.youtube.com/watch?v=ZgWH_LeMkso